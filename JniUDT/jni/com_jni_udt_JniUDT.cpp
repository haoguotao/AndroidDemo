/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <android/log.h>
#include <string>

#include "udt.h"
#include <com_jni_udt_JniUDT.h>

namespace
{
    std::string to_string(int value)
    {
        char buffer[100] = { 0 };
        sprintf(buffer, "%d", value);
        return std::string(buffer);
    }
}

const char TAG[] = "UDT-JNI";

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    startup
 * Signature: ()I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_startup(JNIEnv *, jobject)
{
    return UDT::startup();
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    cleanup
 * Signature: ()I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_cleanup(JNIEnv *, jobject)
{
    return UDT::cleanup();
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    socket
 * Signature: ()I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_socket(JNIEnv *, jobject)
{
    struct addrinfo hints, *local;

    memset(&hints, 0, sizeof(struct addrinfo));

    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    int result = 0;
    if ((result = getaddrinfo(NULL, "9000", &hints, &local)) != 0)
    {
        std::string error = "incorrect network address" + to_string(result);
        __android_log_write(ANDROID_LOG_ERROR, TAG, error.c_str());
        return 0;
    }

    int handle = UDT::socket(local->ai_family, local->ai_socktype, local->ai_protocol);
    freeaddrinfo(local);

    return handle;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    connect
 * Signature: (ILjava/lang/String;I)I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_connect(JNIEnv* env, jobject thiz, jint handle, jstring ip, jint port)
{
    const char *ip_address = env->GetStringUTFChars(ip, NULL);

    struct addrinfo hints, *peer;
    memset(&hints, 0, sizeof(struct addrinfo));

    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    std::string port_str = to_string(port);
    if (0 != getaddrinfo(ip_address, port_str.c_str(), &hints, &peer))
    {
        __android_log_write(ANDROID_LOG_ERROR, TAG, "incorrect server/peer address. ");
        return 0;
    }

    // connect to the server, implict bind
    int connect_result = 0;
    if ((connect_result = UDT::connect(handle, peer->ai_addr, peer->ai_addrlen)) == UDT::ERROR)
    {
        __android_log_write(ANDROID_LOG_ERROR, TAG, "connect error");
        return 0;
    }

    freeaddrinfo(peer);
    return connect_result;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    close
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_close(JNIEnv *env, jobject thiz, jint handle)
{
    return UDT::close(handle);
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    send
 * Signature: (I[BIII)I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_send(JNIEnv *env, jobject thiz, jint handle, jbyteArray buffer, jint offset, jint max_send, jint flag)
{
    jbyte *local_buffer = new jbyte[max_send];
    env->GetByteArrayRegion(buffer, offset, max_send, local_buffer);

    int sent_size = UDT::send(handle, (const char*) local_buffer, max_send, flag);
    if (sent_size == UDT::ERROR)
    {
        __android_log_write(ANDROID_LOG_ERROR, TAG, UDT::getlasterror().getErrorMessage());
    }

    delete local_buffer;
    return sent_size;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    recv
 * Signature: (I[BIII)I
 */
JNIEXPORT jint JNICALL
Java_com_jni_udt_JniUDT_recv(JNIEnv *env, jobject thiz, jint handle, jbyteArray buffer, jint offset, jint max_read, jint flags)
{
    jbyte *local_buffer = new jbyte[max_read];

    int recv_size = 0;
    if (UDT::ERROR == (recv_size = UDT::recv(handle, (char*) local_buffer, max_read, flags)))
    {
        recv_size = 0;
        __android_log_write(ANDROID_LOG_ERROR, TAG, UDT::getlasterror().getErrorMessage());
    }

    env->SetByteArrayRegion(buffer, offset, recv_size, local_buffer);

    delete local_buffer;
    return recv_size;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    bind
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jni_udt_JniUDT_bind (JNIEnv *env, jobject thiz, jint handle, jint port)
{
    struct addrinfo hints, *local;
    memset(&hints, 0, sizeof(struct addrinfo));

    std::string port_str = to_string(port);

    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    int result = 0;
    if ((result = getaddrinfo(NULL, port_str.c_str(), &hints, &local)) != 0)
    {
        std::string error = "incorrect network address" + to_string(result);
        __android_log_write(ANDROID_LOG_ERROR, TAG, error.c_str());
        return 0;
    }

    int ret = UDT::bind(handle,local->ai_addr, local->ai_addrlen);

    return ret;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    listen
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jni_udt_JniUDT_listen (JNIEnv *env, jobject thiz, jint handle, jint backlog)
{
    int ret = UDT::listen(handle, backlog);

    return ret;
}

/*
 * Class:     com_jni_udt_JniUDT
 * Method:    accept
 * Signature: (I)Lcom/jni/udt/AcceptResult;
 */
JNIEXPORT jobject JNICALL Java_com_jni_udt_JniUDT_accept (JNIEnv *env, jobject thiz, jint handle)
{
    sockaddr_storage clientaddr;
    int addrlen = sizeof(clientaddr);

    int socket = UDT::accept(handle, (sockaddr*)&clientaddr, &addrlen);

    char clienthost[NI_MAXHOST];
    char clientservice[NI_MAXSERV];
    getnameinfo((sockaddr *)&clientaddr, addrlen, clienthost, sizeof(clienthost), clientservice, sizeof(clientservice), NI_NUMERICHOST|NI_NUMERICSERV);

    jstring addr = env->NewStringUTF(clienthost);
    jstring port = env->NewStringUTF(clientservice);

    //----Generate AcceptResult
    jclass jcAR = env->FindClass("com/jni/udt/AcceptResult");
    jmethodID constrocMID = env->GetMethodID(jcAR, "<init>", "(ILjava/lang/String;Ljava/lang/String;)V");
    jobject m_obj = env->NewObject(jcAR, constrocMID, socket, addr, port);

    __android_log_write(ANDROID_LOG_ERROR, TAG, clienthost);
    __android_log_write(ANDROID_LOG_ERROR, TAG, clientservice);

    return m_obj;
}
